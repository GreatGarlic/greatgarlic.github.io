[{"title":"Vue工程初始化","date":"2018-08-07T06:46:20.000Z","path":"2018/08/07/vue-init/","text":"全局安装 vue-cli;1$ npm install --global vue-cli; 创建一个基于 webpack 模板的新工程1$ vue init webpack &lt;工程名称&gt;; 进入工程根目录1$ cd &lt;工程名称&gt;; 安装Npm依赖1$ npm install; 运行工程1$ npm run dev; 打包构建工程1$ npm run build;","link":"","tags":[{"name":"Vue","slug":"Vue","permalink":"https://greatgarlic.github.io/tags/Vue/"}]},{"title":"删除 node_modules文件夹","date":"2018-08-07T06:32:59.000Z","path":"2018/08/07/delete-node-modules/","text":"安装 rimraf1npm install rimraf -g 使用rimraf删除node_modules文件夹1rimraf node_modules","link":"","tags":[{"name":"npm","slug":"npm","permalink":"https://greatgarlic.github.io/tags/npm/"}]},{"title":"node,npm 更新","date":"2018-08-07T04:09:23.000Z","path":"2018/08/07/update-npm-self/","text":"升级node1234//先安装模块n$ npm install n -g;//将 node 升级到最新稳定版$ n stable; 将npm升级到最新版1npm install npm@latest -g","link":"","tags":[{"name":"npm","slug":"npm","permalink":"https://greatgarlic.github.io/tags/npm/"}]},{"title":"更新npm依赖包版本","date":"2018-08-07T03:46:38.000Z","path":"2018/08/07/update-npm-package/","text":"安装npm-check1$ npm install -g npm-check; 使用npm-check检查当前工程的package更新情况1$ npm-check -u; 使用npm-check检查全局的package更新情况1$ npm-check -u -g; 空格选择更新,回车开始更新12345678910The global path you are searching is: C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules? Choose which packages to update. (Press &lt;space&gt; to select) Patch Update Backwards-compatible bug fixes.&gt;( ) yarn 1.9.2 ❯ 1.9.4 https://github.com/yarnpkg/yarn#readme Major Update Potentially breaking API changes. Use caution. ( ) cnpm 5.1.1 ❯ 6.0.0 https://github.com/cnpm/cnpm Space to select. Enter to start upgrading. Control-C to cancel. 使用npm-check立刻更新package1$ npm-check -y;","link":"","tags":[{"name":"npm","slug":"npm","permalink":"https://greatgarlic.github.io/tags/npm/"}]},{"title":"安装npm自动更换源插件","date":"2018-08-07T02:06:44.000Z","path":"2018/08/07/node-npm/","text":"安装nrm1$ npm install -g nrm; 查看源12345678$ nrm ls;* npm ----- https://registry.npmjs.org/ cnpm ---- http://r.cnpmjs.org/ taobao -- https://registry.npm.taobao.org/ nj ------ https://registry.nodejitsu.com/ rednpm -- http://registry.mirror.cqupt.edu.cn skimdb -- https://skimdb.npmjs.com/registry 测试源速度123456789$ nrm test; npm ---- 731ms cnpm --- 272ms* taobao - 200ms nj ----- Fetch Error rednpm - Fetch Error npmMirror 1249ms edunpm - Fetch Error 使用指定的源1$ nrm use &lt;源名称&gt;;","link":"","tags":[{"name":"npm","slug":"npm","permalink":"https://greatgarlic.github.io/tags/npm/"}]},{"title":"Oracle 数据导入导出","date":"2018-07-28T16:12:59.000Z","path":"2018/07/29/oracle-data-import-and-export/","text":"本地连接Oracle数据库1$ sqlplus sys/&lt;password&gt; as sysdba; 远程连接Oracle数据库1$ sqlplus &lt;username&gt;/&lt;password&gt;@&lt;ip&gt;:&lt;port&gt;/&lt;SID&gt;; 创建dump文件存储目录1sql&gt; create or replace directory dump_dir as &apos;/u01/app/oracle/dumpfile&apos;; 对dump文件目录赋予读写权限1sql&gt; grant read,write on directory dump_dir to public; 本地导出指定用户的数据库1$ expdp &lt;username&gt;/&lt;password&gt; schemas=&lt;username&gt; directory=dump_dir dumpfile=&lt;username&gt;.dmp version=&lt;target_database_version&gt;; 远程导出指定用户的数据库1$ expdp &lt;username&gt;/&lt;password&gt;@&lt;ip&gt;:&lt;port&gt;/&lt;SID&gt; schemas=&lt;username&gt; directory=dump_dir dumpfile=&lt;username&gt;.dmp version=&lt;target_database_version&gt;; 本地导入指定用户的数据库1$ impdp &lt;username&gt;/&lt;password&gt; DIRECTORY=dump_dir DUMPFILE=&lt;username&gt;.dmp SCHEMAS=&lt;username&gt;; 远程导入指定用户的数据库1$ impdp &lt;username&gt;/&lt;password&gt;@&lt;ip&gt;:&lt;port&gt;/&lt;SID&gt; DIRECTORY=dump_dir DUMPFILE=&lt;username&gt;.dmp SCHEMAS=&lt;username&gt;; 远程导入自定义用户名和自定义表空间的数据库1$ impdp &lt;username&gt;/&lt;password&gt;@&lt;ip&gt;:&lt;port&gt;/&lt;SID&gt; DIRECTORY=dump_dir DUMPFILE=&lt;username&gt;.dmp remap_schema=&quot;&lt;source_username&gt;:&lt;target_username&gt;&quot; remap_tablespace=&quot;&lt;source_tablespace&gt;:&lt;target_tablespace&gt;&quot;; 1234567891011121314alter database datafile &apos;/opt/oracle/product/12.2.0.1/dbhome_1/dbs/D:apporcloradatagwcompSL_GW_COM_XXY_TSPC.dbf&apos; offline drop; drop tablespace SL_GW_COM_TSPC including contents cascade constraints; alter user sys account unlock; conn sys/&lt;password&gt; expdp &lt;username&gt;/&lt;password&gt;@&lt;ip&gt;:&lt;port&gt;/&lt;SID&gt; directory=dump_dir dumpfile=&lt;username&gt;.dmp include=job content=metadata_only drop tablespace UNDOTBS1 including contents and datafiles;drop user WUHAN_ZY cascade;drop user GAOPAN cascade;","link":"","tags":[{"name":"Oracle数据维护","slug":"Oracle数据维护","permalink":"https://greatgarlic.github.io/tags/Oracle数据维护/"}]},{"title":"使用C#开发运行在.Net2.0平台上的HID应用程序,遇到的那些坑","date":"2016-05-22T15:30:30.000Z","path":"2016/05/22/HID-Library_1/","text":"当我们在用C#开发HID应用时，由于是通过DllImport调用的Windows API，在刚开始试用了各种开源HID库，经过尝试均无法正常工作，不是发不出去，就是接受不到消息，经过各种折腾，最后发现由于在调用HID相关的Windows API时，需要在32位的编译平台下编译才可以，于是用刚开始找的开源HID库都调试通过了，由于现成的HID库不符合业务需求，所以重构了一个比较简单的基于.Net2.0的HID库.HidLibrary 支持HID设备插入和拔出事件通知 支持异步接收设备数据 支持主机一次性发送超过64字节的数据 在这里说明如何设置编译器的编译平台，流程为:右击项目-&gt;属性-&gt;生成选项卡-&gt;目标平台-&gt;选择x86-&gt;保存即可。 注意：要求所有依赖该库的项目和库本身都要设置为x86编译平台,如图：","link":"","tags":[{"name":"C#","slug":"C","permalink":"https://greatgarlic.github.io/tags/C/"},{"name":"HID","slug":"HID","permalink":"https://greatgarlic.github.io/tags/HID/"},{"name":"通信","slug":"通信","permalink":"https://greatgarlic.github.io/tags/通信/"},{"name":"类库","slug":"类库","permalink":"https://greatgarlic.github.io/tags/类库/"},{"name":".Net Framework 2.0","slug":"Net-Framework-2-0","permalink":"https://greatgarlic.github.io/tags/Net-Framework-2-0/"}]},{"title":"Java Service Wrapper 包装为Windows服务时，程序无法访问网络磁盘的解决方案","date":"2016-05-22T15:06:21.000Z","path":"2016/05/22/javaServiceWrapper_1/","text":"右键点击服务-&gt;属性-&gt;选择登录选项-&gt;选择`此账户-&gt;浏览-&gt;高级-&gt;立即查找-&gt;选择Administrator账户-&gt;输入账户密码-&gt;确定即可，如下图： 1、右键点击服务-&gt;属性2、选择登录选项卡-&gt;选择此账户3、点击浏览4、点击高级-&gt;立即查找5、选择Administrator账户-&gt;确定6、输入账户密码7、点击确定即可","link":"","tags":[{"name":"Windows服务","slug":"Windows服务","permalink":"https://greatgarlic.github.io/tags/Windows服务/"},{"name":"网络共享磁盘","slug":"网络共享磁盘","permalink":"https://greatgarlic.github.io/tags/网络共享磁盘/"},{"name":"Java Service Wrapper","slug":"Java-Service-Wrapper","permalink":"https://greatgarlic.github.io/tags/Java-Service-Wrapper/"},{"name":"Java程序部署","slug":"Java程序部署","permalink":"https://greatgarlic.github.io/tags/Java程序部署/"}]},{"title":"在使用阿里的开源数据库同步服务otter时，使用Spring-Cache导致Spring找不到Bean方法时的解决方法","date":"2016-05-22T14:48:49.000Z","path":"2016/05/22/canal_1/","text":"由于otter库中依赖了Spring2.5.5,如果你使用较高版本的spring框架库时，会导致类冲突，这个时候，只需要在依赖声明中过滤掉Spring2.5.5即可保证程序正常运行，如图：","link":"","tags":[{"name":"Spring-Cache","slug":"Spring-Cache","permalink":"https://greatgarlic.github.io/tags/Spring-Cache/"},{"name":"canal","slug":"canal","permalink":"https://greatgarlic.github.io/tags/canal/"},{"name":"otter","slug":"otter","permalink":"https://greatgarlic.github.io/tags/otter/"},{"name":"数据库同步","slug":"数据库同步","permalink":"https://greatgarlic.github.io/tags/数据库同步/"},{"name":"mysql","slug":"mysql","permalink":"https://greatgarlic.github.io/tags/mysql/"},{"name":"Alibaba","slug":"Alibaba","permalink":"https://greatgarlic.github.io/tags/Alibaba/"}]},{"title":"关于使用Spring声明式事务，在类的内部方法互相调用时，Spring无法拦截内部方法调用，导致事务不起作用的问题研究","date":"2016-05-22T12:24:21.000Z","path":"2016/05/22/spring-Transaction_1/","text":"一、问题现象： 在程序设计中，有时候我们会遇到一种情况，在一个类的内部进行自我方法调用，然后通过调用这个方法使该方法进入事务管理，如图： Spring声明式事务管理的配置如图：接下来，当我们执行程序后发现控制台打印如下日志： 现在，我们已经知道了本文所描述的问题出现所在，先不解答问题如何处理，我们先了解一下Spring声明式事务的原理，其实Spring是基于它的AOP动态代理技术来实现声明式事务管理的，那么Spring的AOP动态代理又是怎么样的呢？接下来我们会做介绍。 二、SpringAop动态代理： AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP 代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并回调了目标对象的方法。AOP代理所包含的方法与目标对象的方法示意图如图所示： Spring的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC 容器负责管理。因此，AOP代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由IoC容器的依赖注入提供。 纵观AOP编程，其中需要程序员参与的只有3个部分： 1.定义普通业务组件。2.定义切入点，一个切入点可能横切多个业务组件。3.定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。 上面3个部分的第一个部分是最平常不过的事情，无须额外说明。那么进行 AOP 编程的关键就是定义切入点和定义增强处理。一旦定义了合适的切入点和增强处理，AOP 框架将会自动生成 AOP 代理，而 AOP 代理的方法大致有如下公式： 代理对象的方法 = 增强处理 + 被代理对象的方法 在上面这个业务定义中，不难发现 Spring AOP 的实现原理其实很简单：AOP 框架负责动态地生成 AOP 代理类，这个代理类的方法则由 Advice 和回调目标对象的方法所组成。 对于上一张图所示的软件调用结构：当方法 1、方法 2、方法 3 ……都需要去调用某个具有横切性质的方法时，传统的做法是程序员去手动修改方法 1、方法 2、方法 3 ……、通过代码来调用这个具有横切性质的方法，但这种做法的可扩展性不好，因为每次都要改代码。 于是 AOP 框架出现了，AOP 框架则可以“动态的”生成一个新的代理类，而这个代理类所包含的方法 1、方法2、方法 3 ……也增加了调用这个具有“横切”性质的方法——但这种调用由 AOP 框架自动生成的代理类来负责，因此具有了极好的扩展性。程序员无需手动修改方法 1、方法 2、方法 3 的代码，程序员只要定义切入点即可——AOP框架所生成的 AOP 代理类中包含了新的方法 1、访法 2、方法 3，而 AOP 框架会根据切入点来决定是否要在方法1、方法 2、方法 3中回调具有“横切”性质的方法。简而言之：AOP 原理的奥妙就在于动态地生成了代理类。 接下来，来看下我们的业务中，如果要使用AOP，那么过程应该是这样的，如下图所示：但是，实际上我们的代码是这样执行的，如下图： 这样的结果就是，我们先前提到的最初的问题，调用insertValue()方法后，SpringAop拦截不到方法调用，造成无法进入事务管理。 三、解决方案1： 此处的解决方案是参照Spring官方对于自身方法调用的解决方法，利用暴露本地线程，代理目标类，来完成自身调用时，触发AOP拦截，进入事务管理，核心工具类为,AopContext.currentProxy(),从AOP容器中取出代理类，在内部中重新调用要拦截的方法，从而进入事务管理。Spring配置如下图：代码的写法如下图所示：此时进行数据库操作，控制台打印日志如下：当整个入库操作执行完成后，会提交事务，如下图：至此，事务提交完成，此方法可行。 但是，这种方法有一个缺点，具有严重的代码侵入性，导致声明式事务的技术形同虚设，并且如果想取消事务，注释了Spring配置中的AOP相关配置，会出现非受检异常，导致程序无法运行。那么，如何避免具有代码侵入性呢？现在，我们使用解决方案2。 四、解决方案2： 此处的解决方案是利用Spring的IOC容器，从IOC容器中重新获得代理类，调用业务类的insertValue()方法，从而使之进入事务管理，Spring配置如下图： 代码写法如下图：要在类中注入Spring的应用程序上下文。此时，执行程序，并且观察控制台日志，如下图:至此，此解决方案完成。 此方案的优点就是没有严重的代码侵入，并且，当你注释掉SpringAOP配置的时候，运行程序正常，只是不进入事务管理了而已，没有任何其他问题。 唯一的缺点就是，要求程序设计者必须很清楚，哪里该进入事务，哪里就该从SpringIOC容器中取到此对象的实例，并调用要进入事务的方法。最后总结一下就是，程序设计是一门危险的平衡艺术！","link":"","tags":[{"name":"Spring","slug":"Spring","permalink":"https://greatgarlic.github.io/tags/Spring/"},{"name":"事务","slug":"事务","permalink":"https://greatgarlic.github.io/tags/事务/"},{"name":"AOP","slug":"AOP","permalink":"https://greatgarlic.github.io/tags/AOP/"},{"name":"IOC","slug":"IOC","permalink":"https://greatgarlic.github.io/tags/IOC/"}]},{"title":"基于Mybatis持久层框架，使用数据库事务时，插入一条数据后，无法返回主键ID的问题研究","date":"2016-05-22T03:31:46.000Z","path":"2016/05/22/mybatis_1/","text":"一、问题现象： 当我们在使用Mybatis时，然后在加入事务后，在这个时候如果需要插入一条数据后，返回主键ID，如图： 有时会出现如下图的情况： 结果会造成数据插入失败。 二、问题解决： 经过查找官网API说明，发现Mybatis配置中有一项为，defaultExecutorType，如图： 此处的值为：BATCH，BATCH执行器可以重复执行语句和批量更新。其产生的后果是，不会每条SQL语句单独执行，而是一次性批量执行，这样就会导致，在想要实现插入一条数据，返回主键ID时，会请求失败，无法返回，造成整个事务失败然后回滚。 defaultExecutorType还有其他选项：SIMPLE 执行器执行其它语句。REUSE 执行器可能重复使用preparedstatements 语句。经过更改defaultExecutorType执行器选项为SIMPLE 后，如图： 更改后重新运行程序发现插入一条数据后，返回主键ID的请求成功，如图： 至此，在有事务的情况下，将defaultExecutorType选项设置为SIMPLE，插入数据后，便可返回主键ID。","link":"","tags":[{"name":"Java","slug":"Java","permalink":"https://greatgarlic.github.io/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://greatgarlic.github.io/tags/Mybatis/"},{"name":"事务管理","slug":"事务管理","permalink":"https://greatgarlic.github.io/tags/事务管理/"},{"name":"主键ID生成","slug":"主键ID生成","permalink":"https://greatgarlic.github.io/tags/主键ID生成/"}]},{"title":"Netty4.0+内存池的使用心得","date":"2016-05-19T12:15:25.000Z","path":"2016/05/19/netty_1/","text":"一、为什么要使用内存池？ 随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。而且这些实例随着消息的处理朝生夕灭，这就会给服务器带来沉重的GC压力，同时消耗大量的内存。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制。性能测试表明，采用内存池的ByteBuf相比于朝生夕灭的ByteBuf，性能高23倍左右（性能数据与使用场景强相关）。 二、如何启动并初始化内存池 在Netty4.0以上版本中中实现了一个新的ByteBuf内存池，它是一个纯Java版本的 jemalloc （Facebook也在用）。现在，Netty不会再因为用零填充缓冲区而浪费内存带宽了。 不过，由于它不依赖于GC，开发人员需要小心内存泄漏。如果忘记在处理程序中释放缓冲区，那么内存使用率会无限地增长。 Netty默认不使用内存池，需要在创建客户端或者服务端的时候在引导辅助类中进行配置： 123456789101112131415public static void main(String[] args) &#123; //option是boss线程配置,childOption是work线程配置. EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); ServerBootstrap server.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 512) .childOption(ChannelOption.TCP_NODELAY, true) //Boss线程内存池配置. .option(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT) //Work线程内存池配置. .childOption(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT); ChannelFuture f = server.bind(port).sync(); f.channel().closeFuture().sync();&#125; 三、如何在自己的业务代码中使用内存池 首先，介绍一下Netty的ByteBuf缓冲区的种类:ByteBuf支持堆缓冲区和堆外直接缓冲区，根据经验来说，底层IO处理线程的缓冲区使用堆外直接缓冲区，减少一次IO复制。业务消息的编解码使用堆缓冲区，分配效率更高，而且不涉及到内核缓冲区的复制问题。 ByteBuf的堆缓冲区又分为内存池缓冲区PooledByteBuf和普通内存缓冲区UnpooledHeapByteBuf。PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。在高并发的情况下推荐使用PooledByteBuf，可以节约内存的分配。在性能能够保证的情况下，可以使用UnpooledHeapByteBuf，实现比较简单。在此说明这是当我们在业务代码中要使用池化的ByteBuf时的方法： 第一种情况：若我们的业务代码只是为了将数据写入ByteBuf中并发送出去，那么我们应该使用堆外直接缓冲区DirectBuffer.使用方式如下： 1234567891011121314151617public class TestEncode extends MessageToByteEncoder&lt;BasePropertyEntity&gt; &#123; @Override protected void encode(ChannelHandlerContext ctx, BasePropertyEntity msg,ByteBuf outBuffer) throws Exception &#123; int length = 10; //在此使用堆外缓冲区是为了将数据更快速的写入内核中，如果使用堆缓冲区会多一次堆内存向内核进行内存拷贝，这样会降低性能。 ByteBuf buffer = PooledByteBufAllocator.DEFAULT.directBuffer(length); try &#123; byte[] context = new byte[length]; buffer.writeBytes(context); outBuffer.writeBytes(buffer); &#125; finally &#123; // 必须释放自己申请的内存池缓冲区，否则会内存泄露。 //outBuffer是Netty自身Socket发送的ByteBuf系统会自动释放，用户不需要做二次释放。 buffer.release(); &#125; &#125;&#125; 第二种情况：若我们的业务代码中需要访问ByteBuf中的数组时，那么我们应该使用堆缓冲区HeapBuffer.使用方式如下： 12345678910111213byte[] context = new byte[10];int length = 10;// 在此使用堆缓冲区是为了更快速的访问缓冲区内的数组，如果使用堆外缓冲区会多一次内核向堆内存的内存拷贝，这样会降低性能。ByteBuf buffer = PooledByteBufAllocator.DEFAULT.heapBuffer(length);try &#123; buffer.writeBytes(context); // 高效率访问堆缓冲区的方式，具体原因随后会讲。 byte[] dst = new byte[10]; buffer.readBytes(dst);&#125; finally &#123; // 使用完成后一定要记得释放到内存池中。 buffer.release();&#125; 四、高效率访问堆缓冲区数组的方式 经过测试，当使用内存池时，要读去ByteBuf中的数组时: 谨慎使用buffer.readBytes(int length)，推荐使用buffer.readBytes(Byte[] context)，当在读取数组的时候，使用readBytes(int length)时,占用时间为5337387纳秒,如图: 当使用buffer.readBytes(Byte[] context)时，占用时间9741纳秒,如图: 之间相差了547倍的速度。为什么速度差距如此之大，那么我们看下Netty的源码便知，如图：buffer.readBytes(int length)方法的实现： buffer.readBytes(Byte[] context)方法的实现: 所以，总体来说，使用内存池后，应用的性能会大幅提升，但是编码难度从而也会提升，鱼和熊掌往往是不可兼得的，么么哒！","link":"","tags":[{"name":"Netty","slug":"Netty","permalink":"https://greatgarlic.github.io/tags/Netty/"},{"name":"Java","slug":"Java","permalink":"https://greatgarlic.github.io/tags/Java/"},{"name":"NIO","slug":"NIO","permalink":"https://greatgarlic.github.io/tags/NIO/"},{"name":"内存池","slug":"内存池","permalink":"https://greatgarlic.github.io/tags/内存池/"},{"name":"性能优化","slug":"性能优化","permalink":"https://greatgarlic.github.io/tags/性能优化/"}]}]